1. Describe how your exchange works.

At the start of the exchange, it reads and stores products from a file, creates named pipes for traders, forks and executes child traders, connects named pipes, and enters its main loop. 
Upon receiving a SIGUSR1 signal from a trader, the exchange matches the sender's PID with a trader, increments the unread message variable on the matched trader. In the main loop, the exchange checks the pipe of the matched trader, retrieves and queues the order. 
The exchange processes the order queue in a first-in, first-out sequence by extracting information from the order, checking for errors, and sending a response back (either invalid or accepted). 
Accepted orders are processed based on their type, either as new orders matched against existing ones, or as changes or removals command to existing orders.
Finally, the exchange will exit its main loop if all traders are disconnected.

2. Describe your design decisions for the trader and how it's fault-tolerant.
At startup, the trader checks for its ID in the arguments and exits if none is found. This will prevent the error caused by attempting to access a non-existing argument. 
To avoid overflow, underflow, and inconvertible strings when converting string integers to actual integers, a reliable method from Stack Overflow is used. 
The signal handler is optimized to minimize operations and prevent missed signals. The handler only extracts the parent PID and increments a variable. 
The trader will not send another BUY order if its previous order is not accepted to avoid spamming the exchange. 
Finally, before the trader exits, any messages are freed to prevent memory leaks.

3. Describe your tests and how to run them.
Because of limited time, I was only able to implement the end-to-end (E2E) test cases, which are located in the tests/E2E/ directory. Input files are in the .in format, while expected output files are in the .out format.
To run the tests, first enter "make tests" in the command line. This will run the exchange and trader programs with the input files (.in files). The output generated by the exchange program will be stored in the .temp files. Additionally, "make tests" will compile the exchange program using gcov, and the line coverage can be viewed in the "cov.txt" file.
Next, enter "make run_tests" in the command line to compare the .temp files against their corresponding .out files. If there are any differences, the test will be marked as failed. The "make run_tests" output will indicate which test cases have failed and which have passed.

